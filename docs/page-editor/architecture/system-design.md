# システム設計

## 概要

page-editorのシステム設計は、editor-homeとは独立したページ作成システムとして、Notionライクなブロックシステムを実現するための設計です。

## アーキテクチャ概要

```
┌─────────────────┐    ┌─────────────────┐
│   page-editor   │    │   editor-home   │
│   (Frontend)    │◄──►│   (Backend)     │
│                 │    │                 │
│ - Block Editor  │    │ - API Server   │
│ - Block System  │    │ - SQLite DB    │
│ - Preview       │    │ - File Storage │
└─────────────────┘    └─────────────────┘
```

## コンポーネント構成

### 1. フロントエンド（page-editor）

#### エディター層
- **BlockEditor**: エディタブルテキストブロックベースのメインエディター
- **PreviewPane**: リアルタイムプレビュー
- **BlockToolbar**: ブロック挿入ツールバー
- **InlineToolbar**: インライン装飾ツールバー

#### ブロック層
- **BasicBlocks**: テキスト、見出し、リスト等の基本ブロック
- **MediaBlocks**: 画像、動画、音声等のメディアブロック
- **AdvancedBlocks**: 目次、トグル、数式等の応用ブロック
- **DatabaseBlocks**: テーブル、カンバン等のデータベースブロック

#### パネル層
- **ContentSelector**: コンテンツ選択パネル
- **ArticleList**: 記事一覧パネル
- **MediaManager**: メディア管理パネル
- **BlockLibrary**: ブロックライブラリパネル

#### レイアウト層
- **EditorLayout**: メインレイアウト
- **Sidebar**: サイドバーコンポーネント

### 2. バックエンド（editor-home）

#### API層
- **Content API**: コンテンツ管理
- **Markdown API**: マークダウンページ管理
- **Media API**: メディアファイル管理
- **Database API**: データベース操作

#### データ層
- **SQLite Database**: メインデータベース
- **File Storage**: メディアファイル保存
- **Index Management**: コンテンツインデックス

#### サービス層
- **Content Service**: コンテンツビジネスロジック
- **Markdown Service**: マークダウン処理
- **Media Service**: メディア処理
- **Search Service**: 検索機能

## データフロー

### 1. コンテンツ作成フロー
```
ユーザー入力 → エディタブルテキストブロック → Markdown解析 → ブロック変換 → プレビュー表示
     ↓
自動保存 → API呼び出し → データベース保存 → 静的サイト生成
```

### 2. コンテンツ読み込みフロー
```
コンテンツ選択 → API呼び出し → データベース取得 → Markdown変換 → ブロックエディター表示
```

### 3. メディアアップロードフロー
```
ファイル選択 → ドラッグ&ドロップ → Base64変換（10MB以内） → API送信 → データベース保存
```

## 技術スタック

### フロントエンド
- **Next.js 16**: React フレームワーク
- **TypeScript**: 型安全性
- **Tailwind CSS v4**: スタイリング
- **React ContentEditable**: エディタブルテキストブロック
- **React Hooks**: 状態管理

### バックエンド
- **Next.js API Routes**: API サーバー
- **SQLite**: データベース
- **Better SQLite3**: データベースドライバー
- **Node.js**: ランタイム

### ライブラリ
- **Remark**: Markdown解析
- **Prism.js**: シンタックスハイライト
- **KaTeX**: 数式レンダリング
- **React Dropzone**: ファイルアップロード
- **Lucide React**: アイコン

## 設計原則

### 1. モジュラー設計
- **コンポーネント分離**: 各機能の独立性
- **関心の分離**: UI、ロジック、データの分離
- **再利用性**: 共通コンポーネントの活用

### 2. 拡張性
- **プラグインシステム**: カスタムブロックの追加
- **API設計**: RESTful APIの採用
- **型安全性**: TypeScriptによる型定義

### 3. パフォーマンス
- **遅延読み込み**: コンポーネントの遅延読み込み
- **メモ化**: 不要な再レンダリングの防止
- **キャッシュ**: データの効率的なキャッシュ

### 4. セキュリティ
- **入力検証**: ユーザー入力の検証
- **HTMLサニタイゼーション**: XSS対策
- **ファイル検証**: アップロードファイルの検証

## 状態管理

### 1. ブロック状態
- **React Hooks**: useState, useEffect
- **ブロック状態**: 各ブロックの編集状態
- **プレビュー状態**: プレビュー表示の状態

### 2. サーバー状態
- **API呼び出し**: データの取得と更新
- **自動保存**: 2秒間隔での自動保存
- **静的生成**: プレビュー用の静的サイト生成

## エラーハンドリング

### 1. フロントエンド
- **エラーバウンダリ**: React Error Boundary
- **ユーザーフィードバック**: エラーメッセージの表示
- **フォールバック**: エラー時の代替表示

### 2. バックエンド
- **API エラー**: HTTPステータスコード
- **ログ記録**: エラーログの記録
- **例外処理**: try-catch文による例外処理

### 3. ネットワーク
- **タイムアウト**: リクエストのタイムアウト
- **リトライ**: 失敗時の再試行
- **オフライン**: オフライン時の対応

## パフォーマンス最適化

### 1. レンダリング最適化
- **静的サイト生成**: プレビュー用の静的ページ生成
- **ブロック単位レンダリング**: 変更されたブロックのみ再レンダリング
- **メモ化**: React.memo, useMemo, useCallback

### 2. バンドル最適化
- **コード分割**: 動的インポート
- **Tree Shaking**: 未使用コードの除去
- **圧縮**: バンドルサイズの最適化

### 3. データ最適化
- **メディアサイズ制限**: 10MB以内のファイル制限
- **Base64エンコード**: バイナリデータの直接埋め込み
- **遅延読み込み**: 必要時のみデータ読み込み

## セキュリティ設計

### 1. 入力検証
- **クライアント側**: リアルタイム検証
- **サーバー側**: 最終的な検証
- **型安全性**: TypeScriptによる型チェック

### 2. データ保護
- **HTMLサニタイゼーション**: XSS対策
- **ファイル検証**: アップロードファイルの検証（10MB以内）
- **Base64エンコード**: バイナリデータの安全な埋め込み

## 監視・ログ

### 1. アプリケーション監視
- **パフォーマンス**: レスポンス時間の監視
- **エラー**: エラー発生率の監視
- **静的生成**: 静的サイト生成の監視

### 2. ログ管理
- **構造化ログ**: JSON形式のログ
- **ログレベル**: エラー、警告、情報の分類
- **ログローテーション**: ログファイルの管理
